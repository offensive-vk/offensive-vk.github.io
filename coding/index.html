<!doctype html><html><head><style>body {letter-spacing: 1px;}input[type='checkbox'] {display: none;}label:before {background: rgb(30, 150, 235);border-radius: 3px;height: 16px;width: 16px;display: inline-block;cursor: pointer;}input[type='checkbox'] + label:before {content: '';background: rgb(30, 150, 235);color: #fff;font-size: 16px;line-height: 16px;text-align: center;}input[type='checkbox']:checked + label:before {content: 'âœ“';}</style></head><body><div style="width: 70vw; margin: 60px auto;"><h1>Competitive Coding - IV Sem</h1><div class="affine-paragraph-block-container"><h2>Very Short Questions [1x10]</h2><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-paragraph-block-container"><h5>Define classes and objects.</h5><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-paragraph-block-container"><p>Classes are blueprints for creating objects. Objects are instances of classes, representing real-world entities with attributes and behaviors.</p><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-paragraph-block-container"><h5>What is the difference between stack and queue?</h5><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-paragraph-block-container"><p>Stack is a Last-In-First-Out (LIFO) data structure, while queue is First-In-First-Out (FIFO). In a stack, elements are inserted and removed from the top, whereas in a queue, elements are inserted at the rear and removed from the front.</p><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-paragraph-block-container"><h5>What is the operation to add elements in a Queue?</h5><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-paragraph-block-container"><p>The operation to add elements in a queue is called "enqueue."</p><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-paragraph-block-container"><h5>What is the operation to remove an elements in a Queue?</h5><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-paragraph-block-container"><p>The operation to remove elements from a queue is called "dequeue."</p><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-paragraph-block-container"><h5>How is C Programming is different from C++ Programming Language?</h5><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-paragraph-block-container"><p>C is a procedural programming language, while C++ supports both procedural and object-oriented programming paradigms. C++ includes features like classes, inheritance, polymorphism, and templates, which are not present in C.</p><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-paragraph-block-container"><h5>What is the main purpose of a Programming Language.</h5><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-paragraph-block-container"><p>The main purpose of a programming language is to provide a set of instructions and syntax for writing software to perform specific tasks or solve problems effectively and efficiently.</p><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-paragraph-block-container"><h5>Name any two popular programming languages.</h5><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-paragraph-block-container"><p>Java and C++.</p><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-paragraph-block-container"><h5>What is the concept of message passing in OOP.</h5><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-paragraph-block-container"><p>Message passing in object-oriented programming refers to the communication between objects by invoking methods or sending messages to each other to perform actions or exchange information.</p><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-paragraph-block-container"><h5>Define Pointer &#x26; Polymorphism.</h5><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-paragraph-block-container"><p>A pointer is a variable that stores the memory address of another variable. Polymorphism is the ability of objects to be treated as instances of their parent class, enabling different objects to be used interchangeably through inheritance and method overriding.</p><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-paragraph-block-container"><h5>What do you mean by Dynamic Polymorphism?</h5><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-paragraph-block-container"><p>Dynamic polymorphism, also known as runtime polymorphism, occurs when the appropriate method to invoke is determined during runtime based on the actual type of the object. It is achieved through method overriding in inheritance hierarchies.</p><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-paragraph-block-container"><h5>Define Inheritance in OOP.</h5><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-paragraph-block-container"><p>Inheritance in object-oriented programming allows a class (subclass) to inherit properties and behaviors from another class (superclass), promoting code reuse and establishing an "is-a" relationship between classes.</p><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-paragraph-block-container"><h5>What does OOP stands for ?</h5><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-paragraph-block-container"><p>OOP stands for Object Oriented Programming.</p><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-paragraph-block-container"><h5>Define Sorting.</h5><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-paragraph-block-container"><p>Sorting is the process of arranging elements in a specific order, such as ascending or descending, according to a predefined criterion, often to make data more organized or accessible for further processing.</p><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-paragraph-block-container"><h2>Short Questions [2x5]</h2><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-paragraph-block-container"><h5>Define Union.</h5><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-paragraph-block-container"><p>A union in programming is a data structure that allows storing different data types in the same memory location. Only one member of the union can hold a value at a time, and accessing one member might overwrite the value of another member.</p><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-paragraph-block-container"><h5>Define LIFO and FIFO.</h5><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-paragraph-block-container"><p>LIFO stands for Last-In-First-Out, where the last element added to a data structure is the first one to be removed.</p><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-paragraph-block-container"><p>FIFO stands for First-In-First-Out, where the first element added to a data structure is the first one to be removed.</p><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-paragraph-block-container"><h5>What do you understand by a Datatype.</h5><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-paragraph-block-container"><p>A datatype defines the type of data that a variable can hold, such as integers, floating-point numbers, characters, etc.</p><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-paragraph-block-container"><h5>Define Constructor &#x26; Destructor in C++.</h5><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-paragraph-block-container"><p>In C++, a constructor is a special member function with the same name as the class, used to initialize objects of that class. A destructor is also a special member function with the same name as the class but prefixed with a tilde (~), used to clean up resources when an object is destroyed.</p><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-paragraph-block-container"><h5>What are access specifiers and mention its types.</h5><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-paragraph-block-container"><p>Access specifiers define the level of access to class members. In C++, there are three types:</p><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-list-block-container"><ol style=""><li>Public: Members are accessible from outside the class.</li></ol><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-list-block-container"><ol style=""><li>Protected: Members are accessible within the class and its derived classes.</li></ol><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-list-block-container"><ol style=""><li>Private: Members are only accessible within the class.</li></ol><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-paragraph-block-container"><h5>Name various type of operators used of operations in C++.</h5><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-paragraph-block-container"><p>In C++, operators are classified into several categories:</p><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-list-block-container"><ol style=""><li>Arithmetic Operators (+, -, *, /, %)</li></ol><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-list-block-container"><ol style=""><li>Relational Operators (==, !=, &#x3C;, >, &#x3C;=, >=)</li></ol><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-list-block-container"><ol style=""><li>Logical Operators (&#x26;&#x26;, ||, !)</li></ol><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-list-block-container"><ol style=""><li>Assignment Operators (=, +=, -=, *=, /=, %=)</li></ol><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-list-block-container"><ol style=""><li>Increment/Decrement Operators (++, --)</li></ol><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-list-block-container"><ol style=""><li>Bitwise Operators (&#x26;, |, ^, ~, &#x3C;&#x3C;, >>)</li></ol><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-list-block-container"><ol style=""><li>Conditional Operator (?:)</li></ol><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-list-block-container"><ol style=""><li>Membership Operators (sizeof, typeof)</li></ol><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-list-block-container"><ol style=""><li>Pointer Operators (*, &#x26;, ->)</li></ol><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-list-block-container"><ol style=""><li>Unary Operators (+, -, !)</li></ol><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-list-block-container"><ol style=""><li>Ternary Operator (? :)</li></ol><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-paragraph-block-container"><h2>Long Questions [16x5]</h2><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-paragraph-block-container"><h4>Explain Bubble Sort with Appropriate Diagrams or Program.</h4><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-paragraph-block-container"><p>Bubble Sort is a simple sorting algorithm that repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order. The pass through the list is repeated until the list is sorted. Here's a step-by-step explanation of the algorithm:</p><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-list-block-container"><ol style=""><li><strong>Start</strong>: Begin at the beginning of the list.</li></ol><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-list-block-container"><ol style=""><li><strong>Compare</strong>: Compare the first two elements of the list. If the first element is greater than the second element, swap them.</li></ol><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-list-block-container"><ol style=""><li><strong>Move</strong>: Move to the next pair of elements in the list and repeat the comparison and swapping process.</li></ol><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-list-block-container"><ol style=""><li><strong>Iteration</strong>: Continue this process until the end of the list is reached. At this point, the largest element in the list will have "bubbled" to the end.</li></ol><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-list-block-container"><ol style=""><li><strong>Repeat</strong>: Repeat the process for the entire list, excluding the last element (which is already in its correct position after the first iteration).</li></ol><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-list-block-container"><ol style=""><li><strong>Continue</strong>: Continue this process for each element in the list until no more swaps are needed. This indicates that the list is sorted.</li></ol><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><pre><code class="code-cpp"><span style="word-wrap: break-word; color: #008000;">// Bubble Sort in C++.</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #AF00DB;">#include</span><span style="word-wrap: break-word; color: #0000FF;"> </span><span style="word-wrap: break-word; color: #A31515;">&#x3C;iostream></span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #AF00DB;">#include</span><span style="word-wrap: break-word; color: #0000FF;"> </span><span style="word-wrap: break-word; color: #A31515;">&#x3C;conio.h></span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #0000FF;">int&#x26;</span><span style="word-wrap: break-word; color: #000000;"> </span><span style="word-wrap: break-word; color: #795E26;">BubbleSort</span><span style="word-wrap: break-word; color: #000000;">(</span><span style="word-wrap: break-word; color: #0000FF;">int</span><span style="word-wrap: break-word; color: #000000;"> </span><span style="word-wrap: break-word; color: #001080;">arr</span><span style="word-wrap: break-word; color: #000000;">[], </span><span style="word-wrap: break-word; color: #0000FF;">int</span><span style="word-wrap: break-word; color: #000000;"> </span><span style="word-wrap: break-word; color: #001080;">size</span><span style="word-wrap: break-word; color: #000000;">) {</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">    </span><span style="word-wrap: break-word; color: #0000FF;">int</span><span style="word-wrap: break-word; color: #000000;"> x = size;</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">    </span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">    </span><span style="word-wrap: break-word; color: #AF00DB;">for</span><span style="word-wrap: break-word; color: #000000;">(</span><span style="word-wrap: break-word; color: #0000FF;">int</span><span style="word-wrap: break-word; color: #000000;"> i = </span><span style="word-wrap: break-word; color: #098658;">0</span><span style="word-wrap: break-word; color: #000000;">; i &#x3C; x - </span><span style="word-wrap: break-word; color: #098658;">1</span><span style="word-wrap: break-word; color: #000000;">; i++) {</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">        </span><span style="word-wrap: break-word; color: #AF00DB;">for</span><span style="word-wrap: break-word; color: #000000;">(</span><span style="word-wrap: break-word; color: #0000FF;">int</span><span style="word-wrap: break-word; color: #000000;"> j = </span><span style="word-wrap: break-word; color: #098658;">0</span><span style="word-wrap: break-word; color: #000000;">; j &#x3C; x - </span><span style="word-wrap: break-word; color: #098658;">1</span><span style="word-wrap: break-word; color: #000000;"> - i; j++) {</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">            </span><span style="word-wrap: break-word; color: #AF00DB;">if</span><span style="word-wrap: break-word; color: #000000;">(</span><span style="word-wrap: break-word; color: #001080;">arr</span><span style="word-wrap: break-word; color: #000000;">[j] > </span><span style="word-wrap: break-word; color: #001080;">arr</span><span style="word-wrap: break-word; color: #000000;">[j + </span><span style="word-wrap: break-word; color: #098658;">1</span><span style="word-wrap: break-word; color: #000000;">]) {</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">                </span><span style="word-wrap: break-word; color: #0000FF;">int</span><span style="word-wrap: break-word; color: #000000;"> temp = </span><span style="word-wrap: break-word; color: #001080;">arr</span><span style="word-wrap: break-word; color: #000000;">[j];</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">                </span><span style="word-wrap: break-word; color: #001080;">arr</span><span style="word-wrap: break-word; color: #000000;">[j] = </span><span style="word-wrap: break-word; color: #001080;">arr</span><span style="word-wrap: break-word; color: #000000;">[j + </span><span style="word-wrap: break-word; color: #098658;">1</span><span style="word-wrap: break-word; color: #000000;">];</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">                </span><span style="word-wrap: break-word; color: #001080;">arr</span><span style="word-wrap: break-word; color: #000000;">[j + </span><span style="word-wrap: break-word; color: #098658;">1</span><span style="word-wrap: break-word; color: #000000;">] = temp;</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">            }</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">        }</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">    }</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">    </span><span style="word-wrap: break-word; color: #AF00DB;">return</span><span style="word-wrap: break-word; color: #000000;"> *arr;</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">}</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #0000FF;">int</span><span style="word-wrap: break-word; color: #000000;"> </span><span style="word-wrap: break-word; color: #795E26;">main</span><span style="word-wrap: break-word; color: #000000;">(</span><span style="word-wrap: break-word; color: #0000FF;">int</span><span style="word-wrap: break-word; color: #000000;"> </span><span style="word-wrap: break-word; color: #001080;">argc</span><span style="word-wrap: break-word; color: #000000;">, </span><span style="word-wrap: break-word; color: #0000FF;">char</span><span style="word-wrap: break-word; color: #000000;"> </span><span style="word-wrap: break-word; color: #0000FF;">**</span><span style="word-wrap: break-word; color: #001080;">argv</span><span style="word-wrap: break-word; color: #000000;">[]) {</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">    </span><span style="word-wrap: break-word; color: #0000FF;">int</span><span style="word-wrap: break-word; color: #000000;"> size = </span><span style="word-wrap: break-word; color: #098658;">0</span><span style="word-wrap: break-word; color: #000000;">;</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">    </span><span style="word-wrap: break-word; color: #267F99;">std</span><span style="word-wrap: break-word; color: #000000;">::cout &#x3C;&#x3C; </span><span style="word-wrap: break-word; color: #A31515;">"Please Enter The Size of Array : "</span><span style="word-wrap: break-word; color: #000000;"> &#x3C;&#x3C; </span><span style="word-wrap: break-word; color: #267F99;">std</span><span style="word-wrap: break-word; color: #000000;">::endl;</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">    </span><span style="word-wrap: break-word; color: #267F99;">std</span><span style="word-wrap: break-word; color: #000000;">::cin >> size;</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">    </span><span style="word-wrap: break-word; color: #0000FF;">int</span><span style="word-wrap: break-word; color: #000000;"> </span><span style="word-wrap: break-word; color: #001080;">arr</span><span style="word-wrap: break-word; color: #000000;">[size];</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">    </span><span style="word-wrap: break-word; color: #AF00DB;">for</span><span style="word-wrap: break-word; color: #000000;">(</span><span style="word-wrap: break-word; color: #0000FF;">int</span><span style="word-wrap: break-word; color: #000000;"> i = </span><span style="word-wrap: break-word; color: #098658;">0</span><span style="word-wrap: break-word; color: #000000;">; i &#x3C; size; i++) {</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">        </span><span style="word-wrap: break-word; color: #267F99;">std</span><span style="word-wrap: break-word; color: #000000;">::cout &#x3C;&#x3C; </span><span style="word-wrap: break-word; color: #A31515;">"Enter The Element At Index : "</span><span style="word-wrap: break-word; color: #000000;"> &#x3C;&#x3C; i &#x3C;&#x3C; </span><span style="word-wrap: break-word; color: #267F99;">std</span><span style="word-wrap: break-word; color: #000000;">::endl;</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">        </span><span style="word-wrap: break-word; color: #267F99;">std</span><span style="word-wrap: break-word; color: #000000;">::cin >> </span><span style="word-wrap: break-word; color: #001080;">arr</span><span style="word-wrap: break-word; color: #000000;">[i];</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">    }</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">    </span><span style="word-wrap: break-word; color: #795E26;">BubbleSort</span><span style="word-wrap: break-word; color: #000000;">(arr, size);</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">    </span><span style="word-wrap: break-word; color: #267F99;">std</span><span style="word-wrap: break-word; color: #000000;">::cout &#x3C;&#x3C; </span><span style="word-wrap: break-word; color: #A31515;">"</span><span style="word-wrap: break-word; color: #EE0000;">\n</span><span style="word-wrap: break-word; color: #A31515;">==================</span><span style="word-wrap: break-word; color: #EE0000;">\n</span><span style="word-wrap: break-word; color: #A31515;">"</span><span style="word-wrap: break-word; color: #000000;"> &#x3C;&#x3C; </span><span style="word-wrap: break-word; color: #267F99;">std</span><span style="word-wrap: break-word; color: #000000;">::endl;</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">    </span><span style="word-wrap: break-word; color: #267F99;">std</span><span style="word-wrap: break-word; color: #000000;">::cout &#x3C;&#x3C; </span><span style="word-wrap: break-word; color: #A31515;">"Array Elements After Sorting : </span><span style="word-wrap: break-word; color: #EE0000;">\n</span><span style="word-wrap: break-word; color: #A31515;">"</span><span style="word-wrap: break-word; color: #000000;"> &#x3C;&#x3C; </span><span style="word-wrap: break-word; color: #267F99;">std</span><span style="word-wrap: break-word; color: #000000;">::endl;</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">    </span><span style="word-wrap: break-word; color: #AF00DB;">for</span><span style="word-wrap: break-word; color: #000000;">(</span><span style="word-wrap: break-word; color: #0000FF;">int</span><span style="word-wrap: break-word; color: #000000;"> val : arr) {</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">        </span><span style="word-wrap: break-word; color: #267F99;">std</span><span style="word-wrap: break-word; color: #000000;">::cout &#x3C;&#x3C; val &#x3C;&#x3C; </span><span style="word-wrap: break-word; color: #267F99;">std</span><span style="word-wrap: break-word; color: #000000;">::endl;</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">    }</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">    </span><span style="word-wrap: break-word; color: #AF00DB;">return</span><span style="word-wrap: break-word; color: #000000;"> </span><span style="word-wrap: break-word; color: #098658;">0</span><span style="word-wrap: break-word; color: #000000;">;</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">}</span></code></pre><div class="affine-paragraph-block-container"><h4>Explain Function Overloading in OOPS with Example.</h4><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-paragraph-block-container"><p>Function overloading is a feature in C++ that allows multiple functions with the same name but different parameter lists to be defined within the same scope. This means that you can have several functions with the same name as long as they have different parameter types, number of parameters, or order of parameters.</p><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><pre><code class="code-cpp"><span style="word-wrap: break-word; color: #008000;">// Example</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #AF00DB;">#include</span><span style="word-wrap: break-word; color: #0000FF;"> </span><span style="word-wrap: break-word; color: #A31515;">&#x3C;iostream></span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #008000;">// Function to calculate the area of a rectangle</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #0000FF;">double</span><span style="word-wrap: break-word; color: #000000;"> </span><span style="word-wrap: break-word; color: #795E26;">area</span><span style="word-wrap: break-word; color: #000000;">(</span><span style="word-wrap: break-word; color: #0000FF;">double</span><span style="word-wrap: break-word; color: #000000;"> </span><span style="word-wrap: break-word; color: #001080;">length</span><span style="word-wrap: break-word; color: #000000;">, </span><span style="word-wrap: break-word; color: #0000FF;">double</span><span style="word-wrap: break-word; color: #000000;"> </span><span style="word-wrap: break-word; color: #001080;">width</span><span style="word-wrap: break-word; color: #000000;">) {</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">    </span><span style="word-wrap: break-word; color: #AF00DB;">return</span><span style="word-wrap: break-word; color: #000000;"> length * width;</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">}</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #008000;">// Function to calculate the area of a circle</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #0000FF;">double</span><span style="word-wrap: break-word; color: #000000;"> </span><span style="word-wrap: break-word; color: #795E26;">area</span><span style="word-wrap: break-word; color: #000000;">(</span><span style="word-wrap: break-word; color: #0000FF;">double</span><span style="word-wrap: break-word; color: #000000;"> </span><span style="word-wrap: break-word; color: #001080;">radius</span><span style="word-wrap: break-word; color: #000000;">) {</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">    </span><span style="word-wrap: break-word; color: #AF00DB;">return</span><span style="word-wrap: break-word; color: #000000;"> </span><span style="word-wrap: break-word; color: #098658;">3.14</span><span style="word-wrap: break-word; color: #000000;"> * radius * radius;</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">}</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #008000;">// Function to calculate the volume of a box</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #0000FF;">double</span><span style="word-wrap: break-word; color: #000000;"> </span><span style="word-wrap: break-word; color: #795E26;">volume</span><span style="word-wrap: break-word; color: #000000;">(</span><span style="word-wrap: break-word; color: #0000FF;">double</span><span style="word-wrap: break-word; color: #000000;"> </span><span style="word-wrap: break-word; color: #001080;">length</span><span style="word-wrap: break-word; color: #000000;">, </span><span style="word-wrap: break-word; color: #0000FF;">double</span><span style="word-wrap: break-word; color: #000000;"> </span><span style="word-wrap: break-word; color: #001080;">width</span><span style="word-wrap: break-word; color: #000000;">, </span><span style="word-wrap: break-word; color: #0000FF;">double</span><span style="word-wrap: break-word; color: #000000;"> </span><span style="word-wrap: break-word; color: #001080;">height</span><span style="word-wrap: break-word; color: #000000;">) {</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">    </span><span style="word-wrap: break-word; color: #AF00DB;">return</span><span style="word-wrap: break-word; color: #000000;"> length * width * height;</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">}</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #0000FF;">int</span><span style="word-wrap: break-word; color: #000000;"> </span><span style="word-wrap: break-word; color: #795E26;">main</span><span style="word-wrap: break-word; color: #000000;">() {</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">    </span><span style="word-wrap: break-word; color: #0000FF;">double</span><span style="word-wrap: break-word; color: #000000;"> rectangleLength = </span><span style="word-wrap: break-word; color: #098658;">5.0</span><span style="word-wrap: break-word; color: #000000;">;</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">    </span><span style="word-wrap: break-word; color: #0000FF;">double</span><span style="word-wrap: break-word; color: #000000;"> rectangleWidth = </span><span style="word-wrap: break-word; color: #098658;">3.0</span><span style="word-wrap: break-word; color: #000000;">;</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">    </span><span style="word-wrap: break-word; color: #0000FF;">double</span><span style="word-wrap: break-word; color: #000000;"> circleRadius = </span><span style="word-wrap: break-word; color: #098658;">2.5</span><span style="word-wrap: break-word; color: #000000;">;</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">    </span><span style="word-wrap: break-word; color: #0000FF;">double</span><span style="word-wrap: break-word; color: #000000;"> boxLength = </span><span style="word-wrap: break-word; color: #098658;">4.0</span><span style="word-wrap: break-word; color: #000000;">;</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">    </span><span style="word-wrap: break-word; color: #0000FF;">double</span><span style="word-wrap: break-word; color: #000000;"> boxWidth = </span><span style="word-wrap: break-word; color: #098658;">2.0</span><span style="word-wrap: break-word; color: #000000;">;</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">    </span><span style="word-wrap: break-word; color: #0000FF;">double</span><span style="word-wrap: break-word; color: #000000;"> boxHeight = </span><span style="word-wrap: break-word; color: #098658;">3.0</span><span style="word-wrap: break-word; color: #000000;">;</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #008000;">    // Calculate and display the area of a rectangle</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">    </span><span style="word-wrap: break-word; color: #267F99;">std</span><span style="word-wrap: break-word; color: #000000;">::cout &#x3C;&#x3C; </span><span style="word-wrap: break-word; color: #A31515;">"Area of rectangle: "</span><span style="word-wrap: break-word; color: #000000;"> &#x3C;&#x3C; </span><span style="word-wrap: break-word; color: #795E26;">area</span><span style="word-wrap: break-word; color: #000000;">(rectangleLength, rectangleWidth) &#x3C;&#x3C; </span><span style="word-wrap: break-word; color: #267F99;">std</span><span style="word-wrap: break-word; color: #000000;">::endl;</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #008000;">    // Calculate and display the area of a circle</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">    </span><span style="word-wrap: break-word; color: #267F99;">std</span><span style="word-wrap: break-word; color: #000000;">::cout &#x3C;&#x3C; </span><span style="word-wrap: break-word; color: #A31515;">"Area of circle: "</span><span style="word-wrap: break-word; color: #000000;"> &#x3C;&#x3C; </span><span style="word-wrap: break-word; color: #795E26;">area</span><span style="word-wrap: break-word; color: #000000;">(circleRadius) &#x3C;&#x3C; </span><span style="word-wrap: break-word; color: #267F99;">std</span><span style="word-wrap: break-word; color: #000000;">::endl;</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #008000;">    // Calculate and display the volume of a box</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">    </span><span style="word-wrap: break-word; color: #267F99;">std</span><span style="word-wrap: break-word; color: #000000;">::cout &#x3C;&#x3C; </span><span style="word-wrap: break-word; color: #A31515;">"Volume of box: "</span><span style="word-wrap: break-word; color: #000000;"> &#x3C;&#x3C; </span><span style="word-wrap: break-word; color: #795E26;">volume</span><span style="word-wrap: break-word; color: #000000;">(boxLength, boxWidth, boxHeight) &#x3C;&#x3C; </span><span style="word-wrap: break-word; color: #267F99;">std</span><span style="word-wrap: break-word; color: #000000;">::endl;</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">    </span><span style="word-wrap: break-word; color: #AF00DB;">return</span><span style="word-wrap: break-word; color: #000000;"> </span><span style="word-wrap: break-word; color: #098658;">0</span><span style="word-wrap: break-word; color: #000000;">;</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">}</span></code></pre><div class="affine-paragraph-block-container"><h4>What are the various types of Inheritance in C++?</h4><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-paragraph-block-container"><p>In C++, inheritance is a mechanism where a new class inherits properties and behaviors (member functions and variables) from an existing class. There are several types of inheritance:</p><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-list-block-container"><ol style=""><li><strong>Single inheritance</strong>: A derived class inherits from only one base class.</li></ol><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-list-block-container"><ol style=""><li><strong>Multiple inheritance</strong>: A derived class inherits from more than one base class. This allows a class to inherit properties and behaviors from multiple sources.</li></ol><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-list-block-container"><ol style=""><li><strong>Multilevel inheritance</strong>: A derived class is created from another derived class. This forms a hierarchy of classes.</li></ol><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-list-block-container"><ol style=""><li><strong>Hierarchical inheritance</strong>: Multiple derived classes are created from a single base class.</li></ol><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-list-block-container"><ol style=""><li><strong>Hybrid inheritance</strong>: It's a combination of multiple and multilevel inheritance. This involves the use of multiple inheritance in a multilevel hierarchy.</li></ol><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-list-block-container"><ol style=""><li><strong>Virtual inheritance</strong>: It's used to resolve ambiguity caused by multiple inheritance by ensuring that only one instance of a common base class is inherited. This is typically used to avoid the "diamond problem," where ambiguity arises due to multiple inheritance paths.</li></ol><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-paragraph-block-container"><h4>Explain the Process of inserting element into a linked list with suitable example.</h4><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-paragraph-block-container"><p>Inserting an element into a linked list involves a few steps. Let's break down the process:</p><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-list-block-container"><ol style=""><li><strong>Create a New Node</strong>: First, you need to create a new node that will contain the data you want to insert.</li></ol><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-list-block-container"><ol style=""><li><strong>Set Data and Pointer</strong>: Assign the data value you want to store in the new node. Then, set the next pointer of the new node to point to the node that the previous node was pointing to.</li></ol><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-list-block-container"><ol style=""><li><strong>Adjust Pointers</strong>: Update the pointers of the nodes surrounding the new node to ensure the new node is properly inserted into the linked list.</li></ol><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-paragraph-block-container"><p>Example of inserting a node at the beginning of a singly linked list:</p><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><pre><code class="code-cpp"><span style="word-wrap: break-word; color: #AF00DB;">#include</span><span style="word-wrap: break-word; color: #0000FF;"> </span><span style="word-wrap: break-word; color: #A31515;">&#x3C;iostream></span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #008000;">// Define the structure for a node</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #0000FF;">struct</span><span style="word-wrap: break-word; color: #000000;"> </span><span style="word-wrap: break-word; color: #267F99;">Node</span><span style="word-wrap: break-word; color: #000000;"> {</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">    </span><span style="word-wrap: break-word; color: #0000FF;">int</span><span style="word-wrap: break-word; color: #000000;"> data;</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">    Node* next;</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">    </span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #008000;">    // Constructor to initialize data and next pointer</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">    </span><span style="word-wrap: break-word; color: #795E26;">Node</span><span style="word-wrap: break-word; color: #000000;">(</span><span style="word-wrap: break-word; color: #0000FF;">int</span><span style="word-wrap: break-word; color: #000000;"> </span><span style="word-wrap: break-word; color: #001080;">value</span><span style="word-wrap: break-word; color: #000000;">) : </span><span style="word-wrap: break-word; color: #795E26;">data</span><span style="word-wrap: break-word; color: #000000;">(value), </span><span style="word-wrap: break-word; color: #795E26;">next</span><span style="word-wrap: break-word; color: #000000;">(</span><span style="word-wrap: break-word; color: #0000FF;">nullptr</span><span style="word-wrap: break-word; color: #000000;">) {}</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">};</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #008000;">// Function to insert a new node at the beginning of the linked list</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #0000FF;">void</span><span style="word-wrap: break-word; color: #000000;"> </span><span style="word-wrap: break-word; color: #795E26;">insertAtBeginning</span><span style="word-wrap: break-word; color: #000000;">(</span><span style="word-wrap: break-word; color: #267F99;">Node</span><span style="word-wrap: break-word; color: #0000FF;">*&#x26;</span><span style="word-wrap: break-word; color: #000000;"> </span><span style="word-wrap: break-word; color: #001080;">head</span><span style="word-wrap: break-word; color: #000000;">, </span><span style="word-wrap: break-word; color: #0000FF;">int</span><span style="word-wrap: break-word; color: #000000;"> </span><span style="word-wrap: break-word; color: #001080;">value</span><span style="word-wrap: break-word; color: #000000;">) {</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #008000;">    // Create a new node with the given value</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">    Node* newNode = </span><span style="word-wrap: break-word; color: #AF00DB;">new</span><span style="word-wrap: break-word; color: #000000;"> </span><span style="word-wrap: break-word; color: #795E26;">Node</span><span style="word-wrap: break-word; color: #000000;">(value);</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">    </span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #008000;">    // Set the next pointer of the new node to point to the current head</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">    </span><span style="word-wrap: break-word; color: #001080;">newNode</span><span style="word-wrap: break-word; color: #000000;">-></span><span style="word-wrap: break-word; color: #001080;">next</span><span style="word-wrap: break-word; color: #000000;"> = head;</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">    </span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #008000;">    // Update the head to point to the new node</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">    head = newNode;</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">}</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #008000;">// Function to print the elements of the linked list</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #0000FF;">void</span><span style="word-wrap: break-word; color: #000000;"> </span><span style="word-wrap: break-word; color: #795E26;">printList</span><span style="word-wrap: break-word; color: #000000;">(</span><span style="word-wrap: break-word; color: #267F99;">Node</span><span style="word-wrap: break-word; color: #0000FF;">*</span><span style="word-wrap: break-word; color: #000000;"> </span><span style="word-wrap: break-word; color: #001080;">head</span><span style="word-wrap: break-word; color: #000000;">) {</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">    </span><span style="word-wrap: break-word; color: #AF00DB;">while</span><span style="word-wrap: break-word; color: #000000;"> (head != </span><span style="word-wrap: break-word; color: #0000FF;">nullptr</span><span style="word-wrap: break-word; color: #000000;">) {</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">        </span><span style="word-wrap: break-word; color: #267F99;">std</span><span style="word-wrap: break-word; color: #000000;">::cout &#x3C;&#x3C; </span><span style="word-wrap: break-word; color: #001080;">head</span><span style="word-wrap: break-word; color: #000000;">-></span><span style="word-wrap: break-word; color: #001080;">data</span><span style="word-wrap: break-word; color: #000000;"> &#x3C;&#x3C; </span><span style="word-wrap: break-word; color: #A31515;">" "</span><span style="word-wrap: break-word; color: #000000;">;</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">        head = </span><span style="word-wrap: break-word; color: #001080;">head</span><span style="word-wrap: break-word; color: #000000;">-></span><span style="word-wrap: break-word; color: #001080;">next</span><span style="word-wrap: break-word; color: #000000;">;</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">    }</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">    </span><span style="word-wrap: break-word; color: #267F99;">std</span><span style="word-wrap: break-word; color: #000000;">::cout &#x3C;&#x3C; </span><span style="word-wrap: break-word; color: #267F99;">std</span><span style="word-wrap: break-word; color: #000000;">::endl;</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">}</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #0000FF;">int</span><span style="word-wrap: break-word; color: #000000;"> </span><span style="word-wrap: break-word; color: #795E26;">main</span><span style="word-wrap: break-word; color: #000000;">() {</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #008000;">    // Initialize an empty linked list</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">    Node* head = </span><span style="word-wrap: break-word; color: #0000FF;">nullptr</span><span style="word-wrap: break-word; color: #000000;">;</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">    </span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #008000;">    // Insert elements into the linked list</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">    </span><span style="word-wrap: break-word; color: #795E26;">insertAtBeginning</span><span style="word-wrap: break-word; color: #000000;">(head, </span><span style="word-wrap: break-word; color: #098658;">3</span><span style="word-wrap: break-word; color: #000000;">);</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">    </span><span style="word-wrap: break-word; color: #795E26;">insertAtBeginning</span><span style="word-wrap: break-word; color: #000000;">(head, </span><span style="word-wrap: break-word; color: #098658;">2</span><span style="word-wrap: break-word; color: #000000;">);</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">    </span><span style="word-wrap: break-word; color: #795E26;">insertAtBeginning</span><span style="word-wrap: break-word; color: #000000;">(head, </span><span style="word-wrap: break-word; color: #098658;">1</span><span style="word-wrap: break-word; color: #000000;">);</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">    </span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #008000;">    // Print the elements of the linked list</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">    </span><span style="word-wrap: break-word; color: #267F99;">std</span><span style="word-wrap: break-word; color: #000000;">::cout &#x3C;&#x3C; </span><span style="word-wrap: break-word; color: #A31515;">"Linked List: "</span><span style="word-wrap: break-word; color: #000000;">;</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">    </span><span style="word-wrap: break-word; color: #795E26;">printList</span><span style="word-wrap: break-word; color: #000000;">(head);</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">    </span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">    </span><span style="word-wrap: break-word; color: #AF00DB;">return</span><span style="word-wrap: break-word; color: #000000;"> </span><span style="word-wrap: break-word; color: #098658;">0</span><span style="word-wrap: break-word; color: #000000;">;</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">}</span><span style="word-wrap: break-word; color: inherit;">
</span></code></pre><div class="affine-paragraph-block-container"><h4>State the difference b/w Stack and Queue.</h4><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-paragraph-block-container"><p>Stack and queue are both abstract data types used to store and manipulate collections of elements, but they have distinct characteristics:</p><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-list-block-container"><ol style=""><li><strong>Ordering</strong>:</li></ol><div class="affine-block-children-container" style="padding-left: 26px;"><div class="affine-list-block-container"><ul style=""><li><strong>Stack</strong>: Follows the Last In, First Out (LIFO) ordering, meaning the last element added to the stack is the first one to be removed. Think of it as a stack of plates, where you can only remove the top plate.</li></ul><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-list-block-container"><ul style=""><li><strong>Queue</strong>: Follows the First In, First Out (FIFO) ordering, meaning the first element added to the queue is the first one to be removed. Think of it as a line of people waiting, where the first person who joined the line is the first one to be served.</li></ul><div class="affine-block-children-container" style="padding-left: 26px;"></div></div></div></div><div class="affine-list-block-container"><ol style=""><li><strong>Operations</strong>:</li></ol><div class="affine-block-children-container" style="padding-left: 26px;"><div class="affine-list-block-container"><ul style=""><li><strong>Stack</strong>: Supports operations like push (to add an element to the top of the stack) and pop (to remove the top element from the stack). It may also support other operations like peek (to view the top element without removing it) and isEmpty (to check if the stack is empty).</li></ul><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-list-block-container"><ul style=""><li><strong>Queue</strong>: Supports operations like enqueue (to add an element to the back of the queue) and dequeue (to remove the front element from the queue). It may also support other operations like peek (to view the front element without removing it) and isEmpty (to check if the queue is empty).</li></ul><div class="affine-block-children-container" style="padding-left: 26px;"></div></div></div></div><div class="affine-list-block-container"><ol style=""><li><strong>Usage</strong>:</li></ol><div class="affine-block-children-container" style="padding-left: 26px;"><div class="affine-list-block-container"><ul style=""><li><strong>Stack</strong>: Used in scenarios where the order of processing needs to be reversed or where the last element added should be processed first. Commonly used in algorithms involving backtracking, recursion, and expression evaluation.</li></ul><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-list-block-container"><ul style=""><li><strong>Queue</strong>: Used in scenarios where elements need to be processed in the order they were added, such as in scheduling tasks, managing resources, or implementing breadth-first search algorithms.</li></ul><div class="affine-block-children-container" style="padding-left: 26px;"></div></div></div></div><div class="affine-list-block-container"><ol style=""><li><strong>Visual Representation</strong>:</li></ol><div class="affine-block-children-container" style="padding-left: 26px;"><div class="affine-list-block-container"><ul style=""><li><strong>Stack</strong>: Can be visualized as a vertical structure where elements are stacked on top of each other.</li></ul><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-list-block-container"><ul style=""><li><strong>Queue</strong>: Can be visualized as a horizontal structure where elements are lined up in a row, with the front and back ends distinguished.</li></ul><div class="affine-block-children-container" style="padding-left: 26px;"></div></div></div></div><div class="affine-paragraph-block-container"><h4>Explain  the Searching Techniques like Binary and Linear Search.</h4><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-list-block-container"><ol style=""><li><strong>Linear Search</strong>:</li></ol><div class="affine-block-children-container" style="padding-left: 26px;"><div class="affine-list-block-container"><ul style=""><li><strong>Description</strong>: Linear search, also known as sequential search, is a simple searching algorithm that checks every element in a list or array sequentially until the target element is found or the end of the list is reached.</li></ul><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-list-block-container"><ul style=""><li><strong>Process</strong>: Starting from the beginning of the list, each element is compared with the target element until a match is found or the end of the list is reached.</li></ul><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-list-block-container"><ul style=""><li><strong>Efficiency</strong>: Linear search has a time complexity of O(n), where n is the number of elements in the list. It performs well for small lists or unsorted data but becomes inefficient for larger lists or when searching for elements in sorted data.</li></ul><div class="affine-block-children-container" style="padding-left: 26px;"></div></div></div></div><div class="affine-list-block-container"><ol style=""><li><strong>Binary Search</strong>:</li></ol><div class="affine-block-children-container" style="padding-left: 26px;"><div class="affine-list-block-container"><ul style=""><li><strong>Description</strong>: Binary search is a more efficient searching algorithm, specifically designed for sorted lists or arrays. It works by repeatedly dividing the search interval in half until the target element is found or the interval becomes empty.</li></ul><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-list-block-container"><ul style=""><li><strong>Process</strong>:</li></ul><div class="affine-block-children-container" style="padding-left: 26px;"><div class="affine-list-block-container"><ul style=""><li>Compare the target element with the middle element of the list.</li></ul><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-list-block-container"><ul style=""><li>If the target matches the middle element, the search is successful.</li></ul><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-list-block-container"><ul style=""><li>If the target is less than the middle element, continue searching in the lower half of the list.</li></ul><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-list-block-container"><ul style=""><li>If the target is greater than the middle element, continue searching in the upper half of the list.</li></ul><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-list-block-container"><ul style=""><li>Repeat this process until the target is found or the search interval becomes empty.</li></ul><div class="affine-block-children-container" style="padding-left: 26px;"></div></div></div></div><div class="affine-list-block-container"><ul style=""><li><strong>Efficiency</strong>: Binary search has a time complexity of O(log n), where n is the number of elements in the list. It is significantly faster than linear search for large lists, as it eliminates half of the remaining elements in each step. However, binary search requires the list to be sorted, which can add an additional overhead if the list is frequently updated.</li></ul><div class="affine-block-children-container" style="padding-left: 26px;"></div></div></div></div><div class="affine-paragraph-block-container"><h4>What are the various types of looping statements available in C++.</h4><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-paragraph-block-container"><p>In C++, there are several looping statements available to execute a block of code repeatedly. Here are the main types:</p><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-list-block-container"><ol style=""><li><strong>for loop</strong>:<code>
</code>for (initialization; condition; update) {
    // code to be executed
}</li></ol><div class="affine-block-children-container" style="padding-left: 26px;"><div class="affine-list-block-container"><ul style=""><li>The<code>for</code>loop iterates over a block of code a fixed number of times. It typically consists of an initialization expression, a condition to be evaluated before each iteration, and an update expression.</li></ul><div class="affine-block-children-container" style="padding-left: 26px;"></div></div></div></div><div class="affine-list-block-container"><ol style=""><li><strong>while loop</strong>:</li></ol><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><pre><code class="code-Plain Text">while (condition) {
    // code to be executed
}</code></pre><div class="affine-list-block-container"><ul style=""><li>The<code>while</code>loop repeats a block of code as long as the specified condition evaluates to true. It is useful when the number of iterations is not known beforehand.</li></ul><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-list-block-container"><ol style=""><li><strong>do-while loop</strong>:</li></ol><div class="affine-block-children-container" style="padding-left: 26px;"><div class="affine-list-block-container"><ul style=""><li>do {
    // code to be executed
} while (condition);
</li></ul><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-list-block-container"><ul style=""><li>The<code>do-while</code>loop is similar to the<code>while</code>loop, but it guarantees that the code inside the loop is executed at least once before checking the condition.</li></ul><div class="affine-block-children-container" style="padding-left: 26px;"></div></div></div></div><div class="affine-list-block-container"><ol style=""><li><strong>range-based for loop (C++11 and later)</strong>:<code>
</code>for (declaration : range) {
    // code to be executed
}
</li></ol><div class="affine-block-children-container" style="padding-left: 26px;"><div class="affine-list-block-container"><ul style=""><li>The range-based<code>for</code>loop is used to iterate over elements in a range, such as arrays, vectors, or other containers. It simplifies iteration and avoids the need for explicit index manipulation.</li></ul><div class="affine-block-children-container" style="padding-left: 26px;"></div></div></div></div><div class="affine-paragraph-block-container"><h4>Explain various types of Constructors in C++ with Example.</h4><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-paragraph-block-container"><p>In C++, constructors are special member functions that are automatically called when an object of a class is created. They are used to initialize the object's data members. There are several types of constructors:</p><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-list-block-container"><ol style=""><li><strong>Default Constructor</strong>:</li></ol><div class="affine-block-children-container" style="padding-left: 26px;"><div class="affine-list-block-container"><ul style=""><li>A constructor with no parameters, or parameters that have default values.</li></ul><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-list-block-container"><ul style=""><li>It is automatically called when an object is created without any arguments.</li></ul><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-paragraph-block-container"><p></p><div class="affine-block-children-container" style="padding-left: 26px;"><pre><code class="code-cpp"><span style="word-wrap: break-word; color: #0000FF;">class</span><span style="word-wrap: break-word; color: #000000;"> </span><span style="word-wrap: break-word; color: #267F99;">MyClass</span><span style="word-wrap: break-word; color: #000000;"> {</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #0000FF;">public:</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">    </span><span style="word-wrap: break-word; color: #795E26;">MyClass</span><span style="word-wrap: break-word; color: #000000;">() {</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #008000;">        // Constructor code</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">    }</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">};</span><span style="word-wrap: break-word; color: inherit;">
</span></code></pre></div></div></div></div><div class="affine-list-block-container"><ol style=""><li><strong>Parameterized Constructor</strong>:</li></ol><div class="affine-block-children-container" style="padding-left: 26px;"><div class="affine-list-block-container"><ul style=""><li>A constructor with parameters used to initialize the object with specific values.</li></ul><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-list-block-container"><ul style=""><li>It allows customization of object initialization based on provided arguments.</li></ul><div class="affine-block-children-container" style="padding-left: 26px;"></div></div></div></div><pre><code class="code-cpp"><span style="word-wrap: break-word; color: #0000FF;">class</span><span style="word-wrap: break-word; color: #000000;"> </span><span style="word-wrap: break-word; color: #267F99;">MyClass</span><span style="word-wrap: break-word; color: #000000;"> {</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #0000FF;">public:</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">    </span><span style="word-wrap: break-word; color: #795E26;">MyClass</span><span style="word-wrap: break-word; color: #000000;">(</span><span style="word-wrap: break-word; color: #0000FF;">int</span><span style="word-wrap: break-word; color: #000000;"> </span><span style="word-wrap: break-word; color: #001080;">value</span><span style="word-wrap: break-word; color: #000000;">) {</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #008000;">        // Constructor code</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">    }</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">};</span><span style="word-wrap: break-word; color: inherit;">
</span></code></pre><div class="affine-list-block-container"><ol style=""><li><strong>Copy Constructor</strong>:</li></ol><div class="affine-block-children-container" style="padding-left: 26px;"><div class="affine-list-block-container"><ul style=""><li>A constructor used to initialize an object with another object of the same class.</li></ul><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-list-block-container"><ul style=""><li>It is called when an object is initialized using another object of the same class, either by direct initialization or by passing as a function argument.</li></ul><div class="affine-block-children-container" style="padding-left: 26px;"></div></div></div></div><div class="affine-paragraph-block-container"><p></p><div class="affine-block-children-container" style="padding-left: 26px;"><pre><code class="code-cpp"><span style="word-wrap: break-word; color: #0000FF;">class</span><span style="word-wrap: break-word; color: #000000;"> </span><span style="word-wrap: break-word; color: #267F99;">MyClass</span><span style="word-wrap: break-word; color: #000000;"> {</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #0000FF;">public:</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">    </span><span style="word-wrap: break-word; color: #795E26;">MyClass</span><span style="word-wrap: break-word; color: #000000;">(</span><span style="word-wrap: break-word; color: #0000FF;">const</span><span style="word-wrap: break-word; color: #000000;"> </span><span style="word-wrap: break-word; color: #267F99;">MyClass</span><span style="word-wrap: break-word; color: #0000FF;">&#x26;</span><span style="word-wrap: break-word; color: #000000;"> </span><span style="word-wrap: break-word; color: #001080;">other</span><span style="word-wrap: break-word; color: #000000;">) {</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #008000;">        // Constructor code</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">    }</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">};</span><span style="word-wrap: break-word; color: inherit;">
</span></code></pre></div></div><div class="affine-list-block-container"><ol style=""><li><strong>Constructor Overloading</strong>:</li></ol><div class="affine-block-children-container" style="padding-left: 26px;"><div class="affine-list-block-container"><ul style=""><li>Defining multiple constructors within the same class, each with a different parameter list.</li></ul><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-list-block-container"><ul style=""><li>Allows the creation of objects using different sets of arguments.</li></ul><div class="affine-block-children-container" style="padding-left: 26px;"></div></div></div></div><div class="affine-paragraph-block-container"><p></p><div class="affine-block-children-container" style="padding-left: 26px;"><pre><code class="code-cpp"><span style="word-wrap: break-word; color: #0000FF;">class</span><span style="word-wrap: break-word; color: #000000;"> </span><span style="word-wrap: break-word; color: #267F99;">MyClass</span><span style="word-wrap: break-word; color: #000000;"> {</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #0000FF;">public:</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">    </span><span style="word-wrap: break-word; color: #795E26;">MyClass</span><span style="word-wrap: break-word; color: #000000;">() {</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #008000;">        // Default constructor code</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">    }</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">    </span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">    </span><span style="word-wrap: break-word; color: #795E26;">MyClass</span><span style="word-wrap: break-word; color: #000000;">(</span><span style="word-wrap: break-word; color: #0000FF;">int</span><span style="word-wrap: break-word; color: #000000;"> </span><span style="word-wrap: break-word; color: #001080;">value</span><span style="word-wrap: break-word; color: #000000;">) {</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #008000;">        // Parameterized constructor code</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">    }</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">};</span><span style="word-wrap: break-word; color: inherit;">
</span></code></pre></div></div><div class="affine-paragraph-block-container"><h4>Explain traversing in Linked List with detail.</h4><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-paragraph-block-container"><p>Traversing a linked list involves visiting each node in the list sequentially in order to access or manipulate its data. Here's a detailed explanation of the traversal process:</p><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-list-block-container"><ol style=""><li><strong>Starting Point</strong>:</li></ol><div class="affine-block-children-container" style="padding-left: 26px;"><div class="affine-list-block-container"><ul style=""><li>Traversal typically begins at the head (or start) of the linked list. This is the first node in the list.</li></ul><div class="affine-block-children-container" style="padding-left: 26px;"></div></div></div></div><div class="affine-list-block-container"><ol style=""><li><strong>Iteration</strong>:</li></ol><div class="affine-block-children-container" style="padding-left: 26px;"><div class="affine-list-block-container"><ul style=""><li>To traverse the list, you move from one node to the next until you reach the end of the list (i.e., you encounter a node with a null pointer).</li></ul><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-list-block-container"><ul style=""><li>Each iteration involves:</li></ul><div class="affine-block-children-container" style="padding-left: 26px;"><div class="affine-list-block-container"><ul style=""><li>Accessing the data stored in the current node.</li></ul><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-list-block-container"><ul style=""><li>Moving to the next node in the list by following the next pointer.</li></ul><div class="affine-block-children-container" style="padding-left: 26px;"></div></div></div></div></div></div><div class="affine-list-block-container"><ol style=""><li><strong>Accessing Data</strong>:</li></ol><div class="affine-block-children-container" style="padding-left: 26px;"><div class="affine-list-block-container"><ul style=""><li>At each node, you can access and manipulate the data stored in that node. This could involve reading the data, updating it, or performing some operation based on it.</li></ul><div class="affine-block-children-container" style="padding-left: 26px;"></div></div></div></div><div class="affine-list-block-container"><ol style=""><li><strong>Next Pointer</strong>:</li></ol><div class="affine-block-children-container" style="padding-left: 26px;"><div class="affine-list-block-container"><ul style=""><li>The next pointer of a node points to the next node in the list. By following this pointer, you move from one node to the next during traversal.</li></ul><div class="affine-block-children-container" style="padding-left: 26px;"></div></div></div></div><div class="affine-list-block-container"><ol style=""><li><strong>End Condition</strong>:</li></ol><div class="affine-block-children-container" style="padding-left: 26px;"><div class="affine-list-block-container"><ul style=""><li>Traversal continues until you reach the end of the list, where the next pointer of the last node points to null. This indicates that there are no more nodes to traverse.</li></ul><div class="affine-block-children-container" style="padding-left: 26px;"></div></div></div></div><div class="affine-list-block-container"><ol style=""><li><strong>Traversal Techniques</strong>:</li></ol><div class="affine-block-children-container" style="padding-left: 26px;"><div class="affine-list-block-container"><ul style=""><li>Traversal can be implemented using various looping constructs such as<code>while</code>loops or<code>for</code>loops. Alternatively, recursion can also be used for traversal.</li></ul><div class="affine-block-children-container" style="padding-left: 26px;"></div></div></div></div><div class="affine-paragraph-block-container"><h4>Explain DMA in C Lang.</h4><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-paragraph-block-container"><p>Dynamic Memory Allocation (DMA) in C refers to the process of allocating memory dynamically at runtime from the heap (also known as the free store) rather than from the stack. DMA allows programs to allocate memory based on runtime requirements, enabling more flexible memory management. The primary functions used for DMA in C are<code>malloc()</code>,<code>calloc()</code>,<code>realloc()</code>, and<code>free()</code>.</p><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-paragraph-block-container"><p>Here's an overview of each function and how they are used:</p><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-list-block-container"><ol style=""><li><strong>malloc()</strong>:</li></ol><div class="affine-block-children-container" style="padding-left: 26px;"><div class="affine-list-block-container"><ul style=""><li>Prototype:<code>void* malloc(size_t size);</code></li></ul><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-list-block-container"><ul style=""><li>Allocates a block of memory of the specified size in bytes.</li></ul><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-list-block-container"><ul style=""><li>Returns a pointer to the beginning of the allocated memory block.</li></ul><div class="affine-block-children-container" style="padding-left: 26px;"></div></div></div></div><pre><code class="code-c"><span style="word-wrap: break-word; color: #0000FF;">int</span><span style="word-wrap: break-word; color: #000000;">* ptr;</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">ptr = (</span><span style="word-wrap: break-word; color: #0000FF;">int</span><span style="word-wrap: break-word; color: #000000;">*)</span><span style="word-wrap: break-word; color: #795E26;">malloc</span><span style="word-wrap: break-word; color: #000000;">(</span><span style="word-wrap: break-word; color: #098658;">5</span><span style="word-wrap: break-word; color: #000000;"> * </span><span style="word-wrap: break-word; color: #0000FF;">sizeof</span><span style="word-wrap: break-word; color: #000000;">(</span><span style="word-wrap: break-word; color: #0000FF;">int</span><span style="word-wrap: break-word; color: #000000;">));</span><span style="word-wrap: break-word; color: #008000;"> // Allocates memory for 5 integers</span><span style="word-wrap: break-word; color: inherit;">
</span></code></pre><div class="affine-list-block-container"><ol style=""><li><strong>calloc()</strong>:</li></ol><div class="affine-block-children-container" style="padding-left: 26px;"><div class="affine-list-block-container"><ul style=""><li>Prototype:<code>void* calloc(size_t num, size_t size);</code></li></ul><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-list-block-container"><ul style=""><li>Allocates a block of memory for an array of elements, each of which is initialized to 0.</li></ul><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-list-block-container"><ul style=""><li>Takes two arguments: the number of elements to allocate and the size of each element in bytes.</li></ul><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-list-block-container"><ul style=""><li>Returns a pointer to the beginning of the allocated memory block.</li></ul><div class="affine-block-children-container" style="padding-left: 26px;"></div></div></div></div><pre><code class="code-c"><span style="word-wrap: break-word; color: #0000FF;">int</span><span style="word-wrap: break-word; color: #000000;">* ptr;</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">ptr = (</span><span style="word-wrap: break-word; color: #0000FF;">int</span><span style="word-wrap: break-word; color: #000000;">*)</span><span style="word-wrap: break-word; color: #795E26;">calloc</span><span style="word-wrap: break-word; color: #000000;">(</span><span style="word-wrap: break-word; color: #098658;">5</span><span style="word-wrap: break-word; color: #000000;">, </span><span style="word-wrap: break-word; color: #0000FF;">sizeof</span><span style="word-wrap: break-word; color: #000000;">(</span><span style="word-wrap: break-word; color: #0000FF;">int</span><span style="word-wrap: break-word; color: #000000;">));</span><span style="word-wrap: break-word; color: #008000;"> // Allocates memory for 5 integers initialized to 0</span><span style="word-wrap: break-word; color: inherit;">
</span></code></pre><div class="affine-list-block-container"><ol style=""><li><strong>realloc()</strong>:</li></ol><div class="affine-block-children-container" style="padding-left: 26px;"><div class="affine-list-block-container"><ul style=""><li>Prototype:<code>void* realloc(void* ptr, size_t size);</code></li></ul><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-list-block-container"><ul style=""><li>Resizes the memory block pointed to by<code>ptr</code>to the specified size.</li></ul><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-list-block-container"><ul style=""><li>If the new size is larger, the contents of the old block up to the size of the new block are preserved.</li></ul><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-list-block-container"><ul style=""><li>If the new size is smaller, the excess data is lost.</li></ul><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-list-block-container"><ul style=""><li>Returns a pointer to the beginning of the resized memory block. If reallocation fails, returns NULL.<code>
</code></li></ul><div class="affine-block-children-container" style="padding-left: 26px;"></div></div></div></div><pre><code class="code-c"><span style="word-wrap: break-word; color: #000000;">ptr = (</span><span style="word-wrap: break-word; color: #0000FF;">int</span><span style="word-wrap: break-word; color: #000000;">*)</span><span style="word-wrap: break-word; color: #795E26;">realloc</span><span style="word-wrap: break-word; color: #000000;">(ptr, </span><span style="word-wrap: break-word; color: #098658;">10</span><span style="word-wrap: break-word; color: #000000;"> * </span><span style="word-wrap: break-word; color: #0000FF;">sizeof</span><span style="word-wrap: break-word; color: #000000;">(</span><span style="word-wrap: break-word; color: #0000FF;">int</span><span style="word-wrap: break-word; color: #000000;">));</span><span style="word-wrap: break-word; color: #008000;"> // Resizes memory block to accommodate 10 integers</span><span style="word-wrap: break-word; color: inherit;">
</span></code></pre><div class="affine-list-block-container"><ol style=""><li><strong>free()</strong>:</li></ol><div class="affine-block-children-container" style="padding-left: 26px;"><div class="affine-list-block-container"><ul style=""><li>Prototype:<code>void free(void* ptr);</code></li></ul><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-list-block-container"><ul style=""><li>Deallocates the memory block pointed to by<code>ptr</code>, making it available for further allocation.</li></ul><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-list-block-container"><ul style=""><li>It is essential to free dynamically allocated memory to prevent memory leaks.</li></ul><div class="affine-block-children-container" style="padding-left: 26px;"></div></div></div></div><pre><code class="code-c"><span style="word-wrap: break-word; color: #795E26;">free</span><span style="word-wrap: break-word; color: #000000;">(ptr);</span><span style="word-wrap: break-word; color: #008000;"> // Deallocates memory block pointed to by ptr</span></code></pre><div class="affine-paragraph-block-container"><h4>What is the difference in Memory Managment in Linked List and Array, Explain in Detail.</h4><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-paragraph-block-container"><p>Memory management in linked lists and arrays differs significantly due to their fundamental differences in structure and allocation.</p><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-paragraph-block-container"><p><strong>Arrays</strong>:</p><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-list-block-container"><ul style=""><li><strong>Contiguous Memory Allocation</strong>: Arrays store elements in contiguous memory locations. This means that all elements of the array are stored one after another in memory.</li></ul><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-list-block-container"><ul style=""><li><strong>Fixed Size</strong>: Arrays have a fixed size, meaning the size of the array is determined at compile time and cannot be changed at runtime.</li></ul><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-list-block-container"><ul style=""><li><strong>Static Memory Allocation</strong>: Memory for arrays is typically allocated statically, either on the stack or in the global memory segment. This means that the size of the array must be known at compile time.</li></ul><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-list-block-container"><ul style=""><li><strong>Access Time</strong>: Accessing elements in an array is fast and efficient because it involves simple pointer arithmetic. Elements can be accessed directly using their indices.</li></ul><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-list-block-container"><ul style=""><li><strong>Insertion and Deletion</strong>: Insertion and deletion operations in arrays can be inefficient, especially when adding or removing elements from the middle of the array. This is because shifting elements may be required to maintain the contiguous nature of the array.</li></ul><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-list-block-container"><ul style=""><li><strong>Dynamic Arrays</strong>: Some programming languages provide dynamic arrays (e.g., C++ vectors or Java ArrayLists) that allow resizing of the array at runtime. However, resizing typically involves creating a new, larger array and copying elements from the old array, which can be inefficient.</li></ul><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-paragraph-block-container"><p><strong>Linked Lists</strong>:</p><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-list-block-container"><ul style=""><li><strong>Non-contiguous Memory Allocation</strong>: Linked lists store elements in non-contiguous memory locations. Each element (node) of the linked list contains a pointer to the next element, forming a chain-like structure.</li></ul><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-list-block-container"><ul style=""><li><strong>Dynamic Size</strong>: Linked lists can dynamically grow or shrink in size at runtime. They do not have a fixed size, and memory is allocated as needed.</li></ul><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-list-block-container"><ul style=""><li><strong>Dynamic Memory Allocation</strong>: Memory for each node of the linked list is allocated dynamically from the heap using functions like<code>malloc()</code>or<code>new</code>in languages like C or C++, respectively.</li></ul><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-list-block-container"><ul style=""><li><strong>Access Time</strong>: Accessing elements in a linked list can be slower compared to arrays because it requires traversing the list from the beginning to reach a specific element. Random access is not possible, and accessing elements by index requires traversing the list sequentially from the head or tail.</li></ul><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-list-block-container"><ul style=""><li><strong>Insertion and Deletion</strong>: Insertion and deletion operations in linked lists can be efficient, especially for operations at the beginning or end of the list. Adding or removing elements at the beginning or end of the list involves updating pointers, which can be done in constant time. However, operations in the middle of the list may require traversing the list to find the insertion or deletion point.</li></ul><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-paragraph-block-container"><h4>Explain Static variables, static class, static method in C++.</h4><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-paragraph-block-container"><p>In C++, the<code>static</code>keyword can be used in various contexts, including variables, methods (functions), and classes, each with its own implications:</p><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-list-block-container"><ol style=""><li><strong>Static Variables</strong>:</li></ol><div class="affine-block-children-container" style="padding-left: 26px;"><div class="affine-list-block-container"><ul style=""><li>When used with variables inside a function or block,<code>static</code>keyword makes the variable retain its value between function calls. It means the variable is initialized only once, and its value persists throughout the program's execution.</li></ul><div class="affine-block-children-container" style="padding-left: 26px;"></div></div></div></div><pre><code class="code-cpp"><span style="word-wrap: break-word; color: #0000FF;">void</span><span style="word-wrap: break-word; color: #000000;"> </span><span style="word-wrap: break-word; color: #795E26;">foo</span><span style="word-wrap: break-word; color: #000000;">() {</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">    </span><span style="word-wrap: break-word; color: #0000FF;">static</span><span style="word-wrap: break-word; color: #000000;"> </span><span style="word-wrap: break-word; color: #0000FF;">int</span><span style="word-wrap: break-word; color: #000000;"> count = </span><span style="word-wrap: break-word; color: #098658;">0</span><span style="word-wrap: break-word; color: #000000;">;</span><span style="word-wrap: break-word; color: #008000;"> // Static variable</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">    count++;</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">    cout &#x3C;&#x3C; </span><span style="word-wrap: break-word; color: #A31515;">"Count: "</span><span style="word-wrap: break-word; color: #000000;"> &#x3C;&#x3C; count &#x3C;&#x3C; endl;</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">}</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #0000FF;">int</span><span style="word-wrap: break-word; color: #000000;"> </span><span style="word-wrap: break-word; color: #795E26;">main</span><span style="word-wrap: break-word; color: #000000;">() {</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">    </span><span style="word-wrap: break-word; color: #795E26;">foo</span><span style="word-wrap: break-word; color: #000000;">();</span><span style="word-wrap: break-word; color: #008000;"> // Output: Count: 1</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">    </span><span style="word-wrap: break-word; color: #795E26;">foo</span><span style="word-wrap: break-word; color: #000000;">();</span><span style="word-wrap: break-word; color: #008000;"> // Output: Count: 2</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">    </span><span style="word-wrap: break-word; color: #795E26;">foo</span><span style="word-wrap: break-word; color: #000000;">();</span><span style="word-wrap: break-word; color: #008000;"> // Output: Count: 3</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">    </span><span style="word-wrap: break-word; color: #AF00DB;">return</span><span style="word-wrap: break-word; color: #000000;"> </span><span style="word-wrap: break-word; color: #098658;">0</span><span style="word-wrap: break-word; color: #000000;">;</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">}</span></code></pre><div class="affine-list-block-container"><ol style=""><li><strong>Static Methods</strong>:</li></ol><div class="affine-block-children-container" style="padding-left: 26px;"><div class="affine-list-block-container"><ul style=""><li>When used with methods (member functions) inside a class,<code>static</code>keyword makes the method belong to the class rather than to any specific object instance. These methods can be called directly on the class without needing an object instance.</li></ul><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-list-block-container"><ul style=""><li>Static methods cannot access non-static (instance) members of the class directly because they don't have access to<code>this</code>pointer.</li></ul><div class="affine-block-children-container" style="padding-left: 26px;"></div></div></div></div><pre><code class="code-cpp"><span style="word-wrap: break-word; color: #0000FF;">class</span><span style="word-wrap: break-word; color: #000000;"> </span><span style="word-wrap: break-word; color: #267F99;">Math</span><span style="word-wrap: break-word; color: #000000;"> {</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #0000FF;">public:</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">    </span><span style="word-wrap: break-word; color: #0000FF;">static</span><span style="word-wrap: break-word; color: #000000;"> </span><span style="word-wrap: break-word; color: #0000FF;">int</span><span style="word-wrap: break-word; color: #000000;"> </span><span style="word-wrap: break-word; color: #795E26;">add</span><span style="word-wrap: break-word; color: #000000;">(</span><span style="word-wrap: break-word; color: #0000FF;">int</span><span style="word-wrap: break-word; color: #000000;"> </span><span style="word-wrap: break-word; color: #001080;">x</span><span style="word-wrap: break-word; color: #000000;">, </span><span style="word-wrap: break-word; color: #0000FF;">int</span><span style="word-wrap: break-word; color: #000000;"> </span><span style="word-wrap: break-word; color: #001080;">y</span><span style="word-wrap: break-word; color: #000000;">) {</span><span style="word-wrap: break-word; color: #008000;"> // Static method</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">        </span><span style="word-wrap: break-word; color: #AF00DB;">return</span><span style="word-wrap: break-word; color: #000000;"> x + y;</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">    }</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">};</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #0000FF;">int</span><span style="word-wrap: break-word; color: #000000;"> </span><span style="word-wrap: break-word; color: #795E26;">main</span><span style="word-wrap: break-word; color: #000000;">() {</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">    </span><span style="word-wrap: break-word; color: #0000FF;">int</span><span style="word-wrap: break-word; color: #000000;"> result = </span><span style="word-wrap: break-word; color: #267F99;">Math</span><span style="word-wrap: break-word; color: #000000;">::</span><span style="word-wrap: break-word; color: #795E26;">add</span><span style="word-wrap: break-word; color: #000000;">(</span><span style="word-wrap: break-word; color: #098658;">3</span><span style="word-wrap: break-word; color: #000000;">, </span><span style="word-wrap: break-word; color: #098658;">5</span><span style="word-wrap: break-word; color: #000000;">);</span><span style="word-wrap: break-word; color: #008000;"> // Calling static method without creating an object</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">    cout &#x3C;&#x3C; </span><span style="word-wrap: break-word; color: #A31515;">"Result: "</span><span style="word-wrap: break-word; color: #000000;"> &#x3C;&#x3C; result &#x3C;&#x3C; endl;</span><span style="word-wrap: break-word; color: #008000;"> // Output: Result: 8</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">    </span><span style="word-wrap: break-word; color: #AF00DB;">return</span><span style="word-wrap: break-word; color: #000000;"> </span><span style="word-wrap: break-word; color: #098658;">0</span><span style="word-wrap: break-word; color: #000000;">;</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">}</span></code></pre><div class="affine-list-block-container"><ol style=""><li><strong>Static Class Members</strong>:</li></ol><div class="affine-block-children-container" style="padding-left: 26px;"><div class="affine-list-block-container"><ul style=""><li>When used with data members inside a class,<code>static</code>keyword makes the member shared by all instances of the class rather than each instance having its own copy.</li></ul><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-list-block-container"><ul style=""><li>Static class members are initialized only once, before any object of the class is created, and their value is the same for all instances of the class.</li></ul><div class="affine-block-children-container" style="padding-left: 26px;"></div></div></div></div><pre><code class="code-cpp"><span style="word-wrap: break-word; color: #0000FF;">class</span><span style="word-wrap: break-word; color: #000000;"> </span><span style="word-wrap: break-word; color: #267F99;">Car</span><span style="word-wrap: break-word; color: #000000;"> {</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #0000FF;">public:</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">    </span><span style="word-wrap: break-word; color: #0000FF;">static</span><span style="word-wrap: break-word; color: #000000;"> </span><span style="word-wrap: break-word; color: #0000FF;">int</span><span style="word-wrap: break-word; color: #000000;"> count;</span><span style="word-wrap: break-word; color: #008000;"> // Static class member</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">    </span><span style="word-wrap: break-word; color: #795E26;">Car</span><span style="word-wrap: break-word; color: #000000;">() {</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">        count++;</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">    }</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">};</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #0000FF;">int</span><span style="word-wrap: break-word; color: #000000;"> </span><span style="word-wrap: break-word; color: #267F99;">Car</span><span style="word-wrap: break-word; color: #000000;">::count = </span><span style="word-wrap: break-word; color: #098658;">0</span><span style="word-wrap: break-word; color: #000000;">;</span><span style="word-wrap: break-word; color: #008000;"> // Initializing static member outside the class</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #0000FF;">int</span><span style="word-wrap: break-word; color: #000000;"> </span><span style="word-wrap: break-word; color: #795E26;">main</span><span style="word-wrap: break-word; color: #000000;">() {</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">    Car car1;</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">    Car car2;</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">    cout &#x3C;&#x3C; </span><span style="word-wrap: break-word; color: #A31515;">"Total cars: "</span><span style="word-wrap: break-word; color: #000000;"> &#x3C;&#x3C; </span><span style="word-wrap: break-word; color: #267F99;">Car</span><span style="word-wrap: break-word; color: #000000;">::count &#x3C;&#x3C; endl;</span><span style="word-wrap: break-word; color: #008000;"> // Output: Total cars: 2</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">    </span><span style="word-wrap: break-word; color: #AF00DB;">return</span><span style="word-wrap: break-word; color: #000000;"> </span><span style="word-wrap: break-word; color: #098658;">0</span><span style="word-wrap: break-word; color: #000000;">;</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">}</span></code></pre><div class="affine-paragraph-block-container"><h4>What do you understand by final keyword? Explain in detail.</h4><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-paragraph-block-container"><p>In C++, the<code>final</code>keyword is used in the context of class inheritance and member functions. It serves different purposes in different contexts:</p><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><div class="affine-list-block-container"><ol style=""><li><strong>Final Classes</strong>:</li></ol><div class="affine-block-children-container" style="padding-left: 26px;"><div class="affine-list-block-container"><ul style=""><li>When applied to a class, the<code>final</code>keyword indicates that the class cannot be used as a base class for further inheritance. It prevents other classes from deriving from it.</li></ul><div class="affine-block-children-container" style="padding-left: 26px;"></div></div></div></div><pre><code class="code-cpp"><span style="word-wrap: break-word; color: #0000FF;">class</span><span style="word-wrap: break-word; color: #000000;"> </span><span style="word-wrap: break-word; color: #267F99;">Base</span><span style="word-wrap: break-word; color: #000000;"> </span><span style="word-wrap: break-word; color: #0000FF;">final</span><span style="word-wrap: break-word; color: #000000;"> {</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #008000;">    // Class definition</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">};</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #008000;">// Error: Cannot derive from final class 'Base'</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #0000FF;">class</span><span style="word-wrap: break-word; color: #000000;"> </span><span style="word-wrap: break-word; color: #267F99;">Derived</span><span style="word-wrap: break-word; color: #000000;"> : </span><span style="word-wrap: break-word; color: #0000FF;">public</span><span style="word-wrap: break-word; color: #000000;"> </span><span style="word-wrap: break-word; color: #267F99;">Base</span><span style="word-wrap: break-word; color: #000000;"> {</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #008000;">    // Class definition</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">};</span><span style="word-wrap: break-word; color: inherit;">
</span></code></pre><div class="affine-list-block-container"><ol style=""><li><strong>Final Virtual Functions</strong>:</li></ol><div class="affine-block-children-container" style="padding-left: 26px;"><div class="affine-list-block-container"><ul style=""><li>When applied to a virtual function in a base class, the<code>final</code>keyword prevents derived classes from overriding that function. It ensures that the function's implementation in the base class cannot be changed in any derived class.</li></ul><div class="affine-block-children-container" style="padding-left: 26px;"></div></div></div></div><pre><code class="code-cpp"><span style="word-wrap: break-word; color: #0000FF;">class</span><span style="word-wrap: break-word; color: #000000;"> </span><span style="word-wrap: break-word; color: #267F99;">Base</span><span style="word-wrap: break-word; color: #000000;"> {</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #0000FF;">public:</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">    </span><span style="word-wrap: break-word; color: #0000FF;">virtual</span><span style="word-wrap: break-word; color: #000000;"> </span><span style="word-wrap: break-word; color: #0000FF;">void</span><span style="word-wrap: break-word; color: #000000;"> </span><span style="word-wrap: break-word; color: #795E26;">foo</span><span style="word-wrap: break-word; color: #000000;">() </span><span style="word-wrap: break-word; color: #0000FF;">final</span><span style="word-wrap: break-word; color: #000000;"> {</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #008000;">        // Function definition</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">    }</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">};</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #0000FF;">class</span><span style="word-wrap: break-word; color: #000000;"> </span><span style="word-wrap: break-word; color: #267F99;">Derived</span><span style="word-wrap: break-word; color: #000000;"> : </span><span style="word-wrap: break-word; color: #0000FF;">public</span><span style="word-wrap: break-word; color: #000000;"> </span><span style="word-wrap: break-word; color: #267F99;">Base</span><span style="word-wrap: break-word; color: #000000;"> {</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #0000FF;">public:</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #008000;">    // Error: Cannot override final function 'foo'</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">    </span><span style="word-wrap: break-word; color: #0000FF;">void</span><span style="word-wrap: break-word; color: #000000;"> </span><span style="word-wrap: break-word; color: #795E26;">foo</span><span style="word-wrap: break-word; color: #000000;">() {</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #008000;">        // Function definition</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">    }</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">};</span><span style="word-wrap: break-word; color: inherit;">
</span></code></pre><div class="affine-list-block-container"><ol style=""><li><strong>Final Non-virtual Functions</strong>:</li></ol><div class="affine-block-children-container" style="padding-left: 26px;"><div class="affine-list-block-container"><ul style=""><li>When applied to a non-virtual member function in a base class, the<code>final</code>keyword has a similar effect as with virtual functions. It prevents derived classes from overriding the function, but this is enforced at compile time, not runtime.</li></ul><div class="affine-block-children-container" style="padding-left: 26px;"></div></div></div></div><pre><code class="code-cpp"><span style="word-wrap: break-word; color: #0000FF;">class</span><span style="word-wrap: break-word; color: #000000;"> </span><span style="word-wrap: break-word; color: #267F99;">Base</span><span style="word-wrap: break-word; color: #000000;"> {</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #0000FF;">public:</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">    </span><span style="word-wrap: break-word; color: #0000FF;">void</span><span style="word-wrap: break-word; color: #000000;"> </span><span style="word-wrap: break-word; color: #795E26;">bar</span><span style="word-wrap: break-word; color: #000000;">() </span><span style="word-wrap: break-word; color: #0000FF;">final</span><span style="word-wrap: break-word; color: #000000;"> {</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #008000;">        // Function definition</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">    }</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">};</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #0000FF;">class</span><span style="word-wrap: break-word; color: #000000;"> </span><span style="word-wrap: break-word; color: #267F99;">Derived</span><span style="word-wrap: break-word; color: #000000;"> : </span><span style="word-wrap: break-word; color: #0000FF;">public</span><span style="word-wrap: break-word; color: #000000;"> </span><span style="word-wrap: break-word; color: #267F99;">Base</span><span style="word-wrap: break-word; color: #000000;"> {</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #0000FF;">public:</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #008000;">    // Error: Cannot override final function 'bar'</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">    </span><span style="word-wrap: break-word; color: #0000FF;">void</span><span style="word-wrap: break-word; color: #000000;"> </span><span style="word-wrap: break-word; color: #795E26;">bar</span><span style="word-wrap: break-word; color: #000000;">() {</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #008000;">        // Function definition</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">    }</span><span style="word-wrap: break-word; color: inherit;">
</span><span style="word-wrap: break-word; color: #000000;">};</span></code></pre><div class="affine-paragraph-block-container"><p></p><div class="affine-block-children-container" style="padding-left: 26px;"></div></div><hr><div class="affine-paragraph-block-container"><h5><strong>Good luck</strong></h5><div class="affine-block-children-container" style="padding-left: 26px;"></div></div></div></body></html>
